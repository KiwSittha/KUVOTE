console.log("üî• SERVER STARTED: KUVote System with BLOCKCHAIN (SEPOLIA) üî•");
require("dotenv").config();

const express = require("express");
const { MongoClient, ObjectId } = require("mongodb");
const cors = require("cors");
const bcrypt = require("bcrypt");
const nodemailer = require("nodemailer");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");

// ‚úÖ ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤ contract ‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå blockchain.js ‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ
const { contract } = require("./blockchain"); 

const app = express();

app.use(cors({
    origin: "*",
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true
}));

app.use(express.json());

// =======================
// MongoDB Connection
// =======================
const client = new MongoClient(process.env.MONGO_URI);
let db;

// ‚ùå ‡∏•‡∏ö let voteBlockchain ‡∏≠‡∏≠‡∏Å (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ Local Chain ‡πÅ‡∏•‡πâ‡∏ß)

async function ensureTTLIndex() {
  try {
    const collection = db.collection("users");
    const indexes = await collection.indexes();

    const ttlIndex = indexes.find(
      (i) =>
        i.name === "createdAt_1" &&
        i.partialFilterExpression?.isVerified === false
    );

    if (ttlIndex) {
      if (ttlIndex.expireAfterSeconds !== 600) {
        await collection.dropIndex("createdAt_1");
        console.log("üóë Dropped old TTL index");
      } else {
        console.log("‚úÖ TTL index status: OK");
        return;
      }
    }

    await collection.createIndex(
      { createdAt: 1 },
      {
        expireAfterSeconds: 600,
        partialFilterExpression: { isVerified: false },
      }
    );
    console.log("‚è≥ TTL index created (10 minutes expire)");
  } catch (error) {
    console.error("‚ö†Ô∏è TTL Index Error:", error.message);
  }
}

// ‚ùå ‡∏•‡∏ö function loadBlockchain() ‡πÅ‡∏•‡∏∞ saveBlockchain() ‡∏≠‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

async function connectDB() {
  try {
    await client.connect();
    db = client.db("vote");
    console.log("‚úÖ MongoDB Connected Successfully");
    await ensureTTLIndex();
    // ‚ùå ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÇ‡∏´‡∏•‡∏î Blockchain ‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô Sepolia
  } catch (err) {
    console.error("‚ùå MongoDB Connection FAILED:", err.message);
    process.exit(1);
  }
}
connectDB();

// =======================
// Mail Configuration (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
// =======================
const transporter = nodemailer.createTransport({
  host: "smtp.gmail.com",
  port: 587,
  secure: false,
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
  tls: {
    ciphers: 'SSLv3'
  }
});

transporter.verify((error, success) => {
  if (error) {
    console.error("‚ùå [MAIL ERROR] ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Gmail ‡πÑ‡∏î‡πâ:", error.message);
  } else {
    console.log("‚úÖ [MAIL READY] ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡πà‡∏á‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô");
  }
});

// =======================
// Routes
// =======================

app.get("/", (req, res) => {
  res.send("üöÄ KUVote API Server with REAL BLOCKCHAIN is Running!");
});

// =======================
// 1. Register Users (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
// =======================
app.post("/register/users", async (req, res) => {
  let insertedId = null;

  try {
    const { email, faculty, loginPassword, votePin } = req.body;
    console.log(`üì• [REGISTER] New request: ${email}`);

    const existingUser = await db.collection("users").findOne({ email });
    if (existingUser) {
        if (!existingUser.isVerified) {
             return res.status(409).json({ message: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏ô" });
        }
        return res.status(409).json({ message: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß" });
    }

    const hashedPassword = await bcrypt.hash(loginPassword, 10);
    const hashedPin = await bcrypt.hash(votePin, 10);

    const result = await db.collection("users").insertOne({
      email,
      faculty,
      loginPassword: hashedPassword,
      votePin: hashedPin,
      isVerified: false,
      hasVoted: false,
      createdAt: new Date(),
    });

    insertedId = result.insertedId;
    
    const verifyToken = jwt.sign(
      { userId: insertedId },
      process.env.JWT_SECRET,
      { expiresIn: "10m" }
    );
    
    const frontendUrl = process.env.FRONTEND_URL ? process.env.FRONTEND_URL.replace(/\/$/, "") : "http://localhost:3000";
    const verifyLink = `${frontendUrl}/verify-email/${verifyToken}`;

    const emailHtml = `
      <div style="font-family: sans-serif; background-color: #f4f4f5; padding: 40px;">
        <div style="max-width: 600px; margin: 0 auto; background-color: #ffffff; border-radius: 10px; overflow: hidden; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
          <div style="background-color: #10B981; padding: 20px; text-align: center; color: white;">
            <h1>KU Vote System</h1>
          </div>
          <div style="padding: 30px; text-align: center;">
            <h2>‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô</h2>
            <p>‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</p>
            <a href="${verifyLink}" style="display: inline-block; background-color: #10B981; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; font-weight: bold; margin: 20px 0;">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ó‡∏±‡∏ô‡∏ó‡∏µ</a>
          </div>
        </div>
      </div>
    `;

    await transporter.sendMail({
      from: `"KUVote System" <${process.env.EMAIL_USER}>`,
      to: email,
      subject: "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì - KUVote",
      html: emailHtml,
    });

    res.status(201).json({ message: "‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏ô" });

  } catch (err) {
    console.error("‚ùå [REGISTER ERROR]:", err.message);
    if (insertedId) await db.collection("users").deleteOne({ _id: insertedId });
    res.status(500).json({ error: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å", details: err.message });
  }
});

// =======================
// 2. Verify Email (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
// =======================
app.get("/verify-email/:token", async (req, res) => {
  try {
    const decoded = jwt.verify(req.params.token, process.env.JWT_SECRET);
    const result = await db.collection("users").updateOne(
      { _id: new ObjectId(decoded.userId), isVerified: false },
      { $set: { isVerified: true } }
    );
    if (result.matchedCount === 0) return res.status(400).send("<h1>‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à</h1><p>‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏</p>");
    res.send("<h1>üéâ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!</h1><p>‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤ Login ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢</p>");
  } catch (err) {
    res.status(400).send("<h1>‚ùå ‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏</h1>");
  }
});

// =======================
// 3. Login (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
// =======================
app.post("/login", async (req, res) => {
  try {
    let { email, loginPassword } = req.body;
    email = email?.trim().toLowerCase();
    const user = await db.collection("users").findOne({ email });

    if (!user) return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏ô‡∏µ‡πâ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö" });
    if (!user.isVerified) return res.status(403).json({ message: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö" });

    const isPasswordCorrect = await bcrypt.compare(loginPassword, user.loginPassword);
    if (!isPasswordCorrect) return res.status(401).json({ message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });

    const token = jwt.sign({ userId: user._id, email: user.email }, process.env.JWT_SECRET, { expiresIn: "1d" });

    res.json({ token, user: { email: user.email, faculty: user.faculty, hasVoted: user.hasVoted } });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// =======================
// 4. Candidates
// =======================

async function getNextCandidateId() {
  const result = await db.collection("counters").findOneAndUpdate(
    { _id: "candidateId" },
    { $inc: { seq: 1 } },
    { upsert: true, returnDocument: "after" }
  );
  // ‡πÅ‡∏Å‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ: ‡∏ï‡∏±‡∏î .value ‡∏ó‡∏¥‡πâ‡∏á‡πÑ‡∏õ‡πÄ‡∏•‡∏¢ ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏™‡πà‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡πÑ‡∏ß‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÅ‡∏ö‡∏ö
  return result.seq || result.value?.seq; 
}

app.post("/candidate", async (req, res) => {
  try {
    const { name, faculty, position, policies } = req.body;
    
    console.log(`üöÄ Adding candidate: ${name} to Blockchain...`);

    // ==========================================
    // üîó 1. ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏õ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏ô Blockchain ‡∏Å‡πà‡∏≠‡∏ô
    // ==========================================
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô addCandidate ‡πÉ‡∏ô Smart Contract
    const tx = await contract.addCandidate(name);
    
    console.log(`‚è≥ Transaction sent! Hash: ${tx.hash}`);
    const receipt = await tx.wait(); // ‡∏£‡∏≠‡∏à‡∏ô‡πÄ‡∏™‡∏£‡πá‡∏à
    
    console.log(`‚úÖ Block confirmed! Candidate added.`);

    // ==========================================
    // üíæ 2. ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á MongoDB
    // ==========================================

    // ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ Candidate ID ‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà Blockchain ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ (‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏≠‡∏á‡∏Å‡πá‡πÑ‡∏î‡πâ)
    // ‡πÅ‡∏ï‡πà‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏á‡πà‡∏≤‡∏¢ ‡πÄ‡∏£‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ getNextCandidateId() ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°
    const candidateId = await getNextCandidateId(); 

    await db.collection("candidates").insertOne({
      candidateId,
      name,
      faculty,
      position,
      policies: policies || [],
      votes: 0,
      createdAt: new Date(),
      txHash: tx.hash // ‡πÄ‡∏Å‡πá‡∏ö‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏ß‡∏¢
    });

    res.status(201).json({ 
        message: "‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ú‡∏π‡πâ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏ó‡∏±‡πâ‡∏á‡πÉ‡∏ô Database ‡πÅ‡∏•‡∏∞ Blockchain", 
        candidateId,
        txHash: tx.hash
    });

  } catch (err) {
    console.error("‚ùå Add Candidate Error:", err);
    res.status(500).json({ error: err.message });
  }
});

app.get("/candidates", async (req, res) => {
  try {
    // 1. ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏à‡∏≤‡∏Å DB
    const candidates = await db.collection("candidates").find({}).toArray();
    
    // 2. üîó ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏≤‡∏Å Blockchain (Real-time)
    // ‡πÉ‡∏ä‡πâ Promise.all ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏ô (‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÄ‡∏£‡πá‡∏ß)
    const candidatesWithVotes = await Promise.all(candidates.map(async (c) => {
        try {
            // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Smart Contract: getVoteCount(id)
            const votesBigInt = await contract.getVoteCount(c.candidateId);
            return { ...c, votes: Number(votesBigInt) }; // ‡πÅ‡∏õ‡∏•‡∏á BigInt ‡πÄ‡∏õ‡πá‡∏ô Number
        } catch (error) {
            console.error(`Error fetching votes for candidate ${c.candidateId}:`, error.message);
            return { ...c, votes: 0 }; // ‡∏ñ‡πâ‡∏≤‡∏î‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ ‡πÉ‡∏´‡πâ‡πÇ‡∏ä‡∏ß‡πå 0 ‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô
        }
    }));
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏°‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô
    candidatesWithVotes.sort((a, b) => b.votes - a.votes);
    
    res.json(candidatesWithVotes);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// =======================
// üîó 5. BLOCKCHAIN VOTING SYSTEM (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡∏°‡πà)
// =======================

app.post("/vote", async (req, res) => {
  try {
    const { email, votePin, candidateId } = req.body;
    
    // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö User ‡πÉ‡∏ô MongoDB
    const user = await db.collection("users").findOne({ email });
    if (!user) return res.status(404).json({ message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ" });
    if (user.hasVoted) return res.status(403).json({ message: "‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ä‡πâ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß" });

    // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö PIN
    const isPinCorrect = await bcrypt.compare(votePin, user.votePin);
    if (!isPinCorrect) return res.status(401).json({ message: "‡∏£‡∏´‡∏±‡∏™‡πÇ‡∏´‡∏ß‡∏ï‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });

    // 3. Hash ‡∏≠‡∏µ‡πÄ‡∏°‡∏•
    const emailHash = crypto.createHash("sha256").update(email).digest("hex");

    console.log(`üöÄ Sending vote to Blockchain... (Email: ${email} -> Candidate: ${candidateId})`);

    // ==========================================
    // üî• ‡∏™‡πà‡∏á Transaction ‡∏Ç‡∏∂‡πâ‡∏ô Blockchain ‡∏à‡∏£‡∏¥‡∏á
    // ==========================================
    
    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Smart Contract: vote(candidateId, emailHash)
    // Admin Wallet ‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ô‡∏à‡πà‡∏≤‡∏¢ Gas
    const tx = await contract.vote(candidateId, emailHash);
    
    console.log(`‚è≥ Transaction sent! Hash: ${tx.hash}`);
    
    // ‡∏£‡∏≠ Mining (‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô Block)
    const receipt = await tx.wait(); 
    
    console.log(`‚úÖ Block confirmed: Block #${receipt.blockNumber}`);

    // ==========================================

    // 4. ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÉ‡∏ô MongoDB
    await db.collection("users").updateOne(
      { email },
      { $set: { hasVoted: true, transactionHash: tx.hash } }
    );

    // (Option) ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡πÉ‡∏ô DB ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô Cache
    await db.collection("candidates").updateOne(
        { candidateId: parseInt(candidateId) },
        { $inc: { votes: 1 } }
    );

    res.json({ 
      message: "‡πÇ‡∏´‡∏ß‡∏ï‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á Blockchain ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß",
      txHash: tx.hash,
      blockNumber: receipt.blockNumber,
      explorerLink: `https://sepolia.etherscan.io/tx/${tx.hash}`
    });

  } catch (err) {
    console.error("‚ùå Vote Error:", err);
    
    // ‡∏î‡∏±‡∏Å Error ‡∏à‡∏≤‡∏Å Blockchain
    if (err.reason) {
        return res.status(400).json({ message: "Blockchain Error: " + err.reason });
    }
    // ‡∏î‡∏±‡∏Å Error ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
    res.status(500).json({ error: err.message || "Unknown error occurred" });
  }
});

// =======================
// üìä Statistics
// =======================

app.get("/stats/vote-summary", async (req, res) => {
  try {
    const result = await db.collection("users").aggregate([
      { $match: { isVerified: true } },
      { $group: { _id: "$hasVoted", count: { $sum: 1 } } },
    ]).toArray();

    let voted = 0;
    let notVoted = 0;
    result.forEach((item) => {
      if (item._id === true) voted = item.count;
      if (item._id === false) notVoted = item.count;
    });

    res.json({ 
      voted, 
      notVoted, 
      totalVerified: voted + notVoted,
      blockchainStatus: "Active (Sepolia)"
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});


// =======================
// Start Server
// =======================
const PORT = process.env.PORT || 8000;
app.listen(PORT, () => {
  console.log(`üöÄ Server running on port ${PORT}`);
  console.log(`‚õìÔ∏è  Blockchain Mode: ONLINE (Sepolia)`);
});